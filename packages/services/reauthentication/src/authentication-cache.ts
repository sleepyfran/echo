import {
  AuthenticationCache,
  AuthenticationInfo,
  BroadcastListener,
  ProviderAuthInfoChanged,
  ProviderId,
} from "@echo/core-types";
import { Effect, Layer, SubscriptionRef, Option, Ref, Stream } from "effect";

type AuthenticationCacheByProvider = Map<ProviderId, AuthenticationInfo>;

/**
 * Implementation of the authentication cache that keeps the state in a
 * subscription ref. Since the tokens need to be refreshed by the main thread
 * (due to potentially requiring user interaction), the cache needs to consume
 * new values via broadcast messages that will be generated by the authentication
 * refresher service.
 */
export const AuthenticationCacheLive = Layer.scoped(
  AuthenticationCache,
  Effect.gen(function* () {
    const cache = yield* SubscriptionRef.make<AuthenticationCacheByProvider>(
      new Map(),
    );

    const broadcastListener = yield* BroadcastListener;
    const authStream = yield* broadcastListener.listen(
      "authentication",
      ProviderAuthInfoChanged,
    );

    yield* authStream.pipe(
      Stream.tap(({ providerId }) =>
        Effect.logInfo(`Received update for ${providerId}, updating cache`),
      ),
      Stream.ensuring(
        Effect.logWarning(
          "Stopped listening for auth updates, was this intended?",
        ),
      ),
      Stream.runForEach(({ providerId, authInfo }) =>
        Ref.update(cache, (cache) => new Map(cache).set(providerId, authInfo)),
      ),
      Effect.forkScoped,
    );

    return AuthenticationCache.of({
      initialSet: (providerId, authInfo) =>
        Effect.gen(function* () {
          const current = yield* cache.get;
          if (current.has(providerId)) {
            yield* Effect.logWarning(
              `Authentication info for ${providerId} already set, ignoring`,
            );
            return;
          }

          yield* Effect.logInfo(
            `Setting initial authentication info for ${providerId}`,
          );
          yield* Ref.update(cache, (cache) =>
            new Map(cache).set(providerId, authInfo),
          );
        }),
      get: (providerId) =>
        cache.get.pipe(
          Effect.map((c) => Option.fromNullable(c.get(providerId))),
          Effect.tap((result) =>
            Option.isNone(result)
              ? Effect.logWarning(
                  `No token found in authentication cache for provider ${providerId}`,
                )
              : Effect.void,
          ),
        ),
    });
  }),
);
