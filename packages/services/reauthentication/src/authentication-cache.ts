import {
  AuthenticationCache,
  AuthenticationInfo,
  BroadcastListener,
  ProviderAuthInfoChanged,
  ProviderId,
} from "@echo/core-types";
import { Effect, Layer, SubscriptionRef, Option, Ref, Stream } from "effect";

type AuthenticationCacheByProvider = Map<ProviderId, AuthenticationInfo>;

/**
 * Implementation of the authentication cache that keeps the state in a
 * subscription ref. Since the tokens need to be refreshed by the main thread
 * (due to potentially requiring user interaction), the cache needs to consume
 * new values via broadcast messages that will be generated by the authentication
 * refresher service.
 */
export const AuthenticationCacheLive = Layer.scoped(
  AuthenticationCache,
  Effect.gen(function* () {
    const cache = yield* SubscriptionRef.make<AuthenticationCacheByProvider>(
      new Map(),
    );

    const broadcastListener = yield* BroadcastListener;
    const authStream = yield* broadcastListener.listen(
      "authentication",
      ProviderAuthInfoChanged,
    );

    yield* authStream.pipe(
      Stream.tap(({ providerId }) =>
        Effect.logInfo(`Received update for ${providerId}, updating cache`),
      ),
      Stream.runForEach(({ providerId, authInfo }) =>
        Ref.update(cache, (cache) => new Map(cache).set(providerId, authInfo)),
      ),
      Effect.forkScoped,
    );

    return AuthenticationCache.of({
      get: (providerId) =>
        cache.get.pipe(
          Effect.map((c) => Option.fromNullable(c.get(providerId))),
        ),
    });
  }),
);
